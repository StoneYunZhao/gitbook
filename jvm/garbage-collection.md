# Garbage Collection

## 前言

### 垃圾回收内存区域

Java 自动内存管理主要针对对象的分配与回收。Java 自动回收内存最主要的区域是堆内存，Hotspot 虚拟机在1.8之前将内存回收拓展到了方法区（永久代）。

![JDK1.8 &#x4E4B;&#x524D;&#x7684;&#x5806;&#x5185;&#x5B58;&#x793A;&#x610F;&#x56FE;](../.gitbook/assets/image%20%2825%29.png)

{% hint style="warning" %}
上图来源网上，我认为不精确，因为永久代是方法区，方法区在 JVM 规范里面不属于堆（Hotspot 可能用堆来实现的方法区）。
{% endhint %}

可以看出垃圾回收区域的分为新生代、老年代和永久代。新生代又被进一步分为：Eden 区＋Survior1 区＋Survior2 区。在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。

### 对象分配策略

#### 优先在 eden 区域分配

大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够的内存时，将先触发一次 Minor GC。

* **Minor GC**：指发生**新生代**的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。
* **Full GC\(Major GC\)**：指发生在**老年代**的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。

#### 大对象直接进入老年代

为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率，所以直接进入老年代，比如需要大量连续内存空间的对象（字符串、数组）。

#### 长期存活的对象进入老年代

虚拟机给每个对象一个对象年龄（Age）计数器，如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

{% hint style="info" %}
**动态年龄判断**：虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。
{% endhint %}

## 对象死亡判断

### 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。

JVM 并没有使用此方法，原因是存在**循环引用**的问题。

### 可达性分析

通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

![](../.gitbook/assets/image%20%281%29.png)

{% hint style="warning" %}
不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，对象死亡，要经历**两次标记**过程。可达性分析法中不可达的对象被**第一次标记**并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。需要执行的对象将会被放在一个队列中进行第**二次标记**，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。
{% endhint %}

### 引用类型

引用计数法与可达性分析都与引用相关。JDK1.2 之后，将引用分为强引用、软引用、弱引用、虚引用。

#### 强引用

我们平时使用的引用即为强引用，如果对象具有强引用，那么垃圾收集器不会回收它，当内存不足时，宁愿抛出 OutOfMemoryError 异常。

#### 软引用

如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。

#### 弱引用

在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存

#### 虚引用

虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。**虚引用主要用来跟踪对象被垃圾回收的活动。**

### 判断常量是废弃的

假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

{% hint style="info" %}
JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。
{% endhint %}

### 判断类是无用的

同时满足以下三个条件：

* 该类所有的实例都已经被回收。
* 加载该类的 ClassLoader 已经被回收。
* 该类对应的 java.lang.Class 对象没有在任何地方被引用。

虚拟机**可以**对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

## 垃圾回收算法

### 标记-清除（Mark-Sweep）

算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

* 效率很高。
* 清除后有很多不连续的碎片。

![](../.gitbook/assets/image%20%2821%29.png)

### 复制

将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。

![](../.gitbook/assets/image%20%2853%29.png)

### 标记-整理（Mark-Compact）

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移动，然后直接清理掉端边界以外的内存。

![](../.gitbook/assets/image%20%2841%29.png)

### 分代收集

根据对象存活周期的不同将内存分为几块，根据各个年代的特点选择合适的垃圾收集算法。

## 垃圾收集器





