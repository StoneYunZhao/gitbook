---
description: 《HTTP/2 in Action》by Barry Pollard 的读书笔记。
---

# HTTP/2 in Action

## Part 1. 向 HTTP/2 靠拢

### Chapter 1. 万维网与 HTTP

#### 1.1 万维网的原理

因特网使用 IP（Internet Protocol）协议，万维网（World Wide Web）有三项核心技术，HTTP、URL、HTML。

![](../../.gitbook/assets/image%20%28337%29.png)

#### 1.2 什么是 HTTP

HTTP 代表超文本传输协议。基于可靠的网络连接，通常为 TCP/IP。是一个请求-响应协议。

#### 1.3 HTTP 的语法和历史

* HTTP/0.9: 没有 header、body，每个请求关闭连接，错误用 HTML 响应文本。
* HTTP/1.0: 更多请求方法，添加版本号字段，首部，整数响应状态码
* HTTP/1.1: 对 1.0 的标准化和完善。强制添加 Host header，持久连接（默认），管道（不流行，且支持较差），cookie。

#### 1.4 HTTPS

HTTP 的安全版本，加密、完整性校验、身份验证。使用 TLS（Transport Layer Security）加密，TLS 的前身是 SSL（Secure Sockets layer）。

HTTPS的一个重大问题是，它只保证你正在连接到该服务器，而不能保证服务器值得信任。

#### 1.5 查看、发送和接收 HTTP 消息的工具

浏览器开发者。

Postman，curl，wget。

### Chapter 2. 通向 HTTP/2 之路

#### 2.1 HTTP 和当前的万维网

在一个连接中，请求 1-&gt; 响应 1 -&gt; 请求 2 -&gt; 响应 2 的工作方式是 HTTP 慢的根本原因，即为了等待响应会阻塞发送，在当前请求完成之前，无法发送另一个请求。

HTTP/1.1 引入管道化，连续发出多个请求，并按照顺序接收响应。但是很难实现，没有一个主流的 Web 浏览器支持管道化技术。而且存在队头（HOL）阻塞问题。

#### 2.2 解决 HTTP/1.1 性能问题的方案

大致分为两类：

* 使用多个 HTTP连接
* 合并 HTTP 请求

使用多连接与管道化相比，不会有 HOL 阻塞问题。多数浏览器可以为每个域名分配 6 个连接。域名分片技术可以开启更多连接。但是也有缺点，建立连接需要时间，维护连接需要 CPU 和内存，TCP 的慢启动算法导致每个连接初始的拥塞窗口都很小。

发送更少的请求，精灵图，CSS 和 JavaScript 文件合并，最小化文件。缺点是引入了复杂度；合并文件会导致浪费，因为不是所有的网站都需要合并文件的所有内容；缓存。

#### 2.3 HTTP/1.1 的其他问题

请求和首部是文本形式，对人类友好，但对机器不友好。

首部内容重复，尤其是 cookie。

#### 2.5 从 HTTP/1.1 到 HTTP/2

SPDY：流多路利用，请求优先级，HTTP 首部压缩，服务器推送。二进制协议。

HTTP/2 是基于 SPDY 的标准化版本。

#### 2.6 HTTP/2 对 Web 性能的影响

大多数网站可以带来很大性能提升。但不能解决所有的性能问题。

### Chapter 3. 升级到 HTTP/2

#### 3.1 HTTP/2 的支持

几乎每个现代浏览器都支持 HTTP/2，仅支持基于 HTTPS 的 HTTP/2 是浏览器厂商遵循的事实上的标准。但是中间代理若不支持，可能降级为 1.1。

几乎所有的服务器也都支持 HTTP/2 了，但是服务器升级比较麻烦，且升级 SSL/TLS 库更麻烦。

如果中间有一环不能支持 HTTP/2，可以降级到 1.1。

#### 3.2 网站开启 HTTP/2 的方法

Web 服务器开启 HTTP/2。

在 Web 服务器前放置一个 HTTP/2 的反向代理服务器，将 HTTP/2 转换为 HTTP/1.1 发送给 Web 服务器。

通过 CDN 实现 HTTP/2。

#### 3.3 常见问题

Web 服务器未启用 ALPN 支持，有些浏览器仅支持 ALPN。ALPN 是 TLS 的扩展。

## Part 2. 使用 HTTP/2

### Chapter 4. HTTP/2 协议基础

#### 4.1 为什么是 HTTP/2 而不是 HTTP/1.2

因为增加了很多概念，是根本上的变化，不向前兼容。

* 二进制的、基于数据包的协议，而 HTTP/1 是完全基于文本的。
* 多路复用替代同步请求，每个帧分配一个流标识符表名属于哪个流。客户端发起的请求使用奇数流 ID，服务器使用偶数流 ID。ID 为 0 的流为管理连接的控制流。

![](../../.gitbook/assets/image%20%28338%29.png)

* 流有优先级。
* 流可以流量控制。TCP 在连接层限流，HTTP/2 在流的层面限流。
* 首部压缩，cookie、user-agent、host、accept-encoding 等基本不变。HTTP/1 仅允许压缩 body。HTTP/2 还能跨请求压缩首部。
* 服务端推送。

#### 4.2 如何创建一个 HTTP/2 连接

浏览器仅支持基于 HTTPS\(h2\) 建立 HTTP/2，服务器之间可以基于 HTTP\(h2c\) 的 HTTP/2。

* 使用 HTTPS 协商，在 HTTPS 握手过程中，同时完成 HTTP/2 协商。ALPN 不会引入额外的消息往返。

![](../../.gitbook/assets/image%20%28336%29.png)

* 使用 HTTP Upgrade header，仅适用于 h2c。客户端发起升级请求，服务端响应是否支持，客户端决定是否升级。
* 使用先验知识。

不管使用哪种方法启用HTTP/2连接，在HTTP/2连接上发送的第一个消息必须是HTTP/2连接前奏，或者说是“魔法”字符串。

#### 4.3 HTTP/2 帧

每个HTTP/2帧由一个固定长度的头部和不定长度的负载组成。

![HTTP/2 &#x5E27;&#x5934;&#x90E8;&#x683C;&#x5F0F;](../../.gitbook/assets/image%20%28340%29.png)

标志位的含义和值取决于帧类型。

* SETTING 帧：服务器和客户端必须发送的第一个帧（除了魔法字符串），只包含键值对。流 ID 为 0。标志位 0 表示发起设置，标志位 1 表示确认设置。
* WINDOW\_UPDATE 帧：用于流量控制。流量控制仅用于 DATA 帧。
* PRIORITY 帧：优先级设定。
* HEADERS 帧：冒号开头是严格定义的伪首部，不能自己随便添加。可以自定义非冒号开头的普通 header。有四个标志位：END\__STREAM, END\__HEADERS, PADDED, PRIORITY
* DATA 帧：消息体。
* GOAWAY 帧：错误或关闭连接。
* CONTINUATION 帧：太大的首部需要。必须紧跟在 HEADERS 帧后面。降低了多路复用性。
* PING 帧：计算消息往返时间。保持一个不使用的连接。
* PUSH\_PROMISE 帧：服务端通知客户端要发起推送。
* RST\_STREAM 帧：直接取消一个流。
* ALTSVC 帧：允许服务端宣告获取资源时可用的其他服务。
* ORIGIN 帧：服务器使用它来宣告自己可以处理哪些源（比如域名）的请求。
* CACHE\_DIGEST 帧：客户端可以使用这个帧来表明自己缓存了哪些资源。

### Chapter 5. 实现 HTTP/2 推送

#### 5.1 什么是 HTTP/2 服务端推送

HTTP/2服务端推送（以下称为HTTP/2推送）允许服务器发回客户端未请求的额外资源。

若服务端知道此页面需要哪些关键资源，不需要等客户端请求而是直接推送，则能减少往返次数。

![](../../.gitbook/assets/image%20%28339%29.png)

需要注意的一个关键点是，仅在响应初始请求时才会发送推送的资源。HTTP/2中不是真正的双向流。推送资源是为了响应初始请求而做出的额外响应。完成该初始请求后，流会被关闭，除非客户端发起其他请求，否则不能推送其他资源。

#### 5.2 如何推送

* 使用HTTP link首部通知Web服务器推送资源。

可以从下游系统推送：

![](../../.gitbook/assets/image%20%28342%29.png)

![](../../.gitbook/assets/image%20%28344%29.png)

可以更早推送：

![](../../.gitbook/assets/image%20%28341%29.png)

不需要在整个链路中都支持推送。

#### 5.3 HTTP/2 推送在浏览器中如何运作

资源不是被直接推到网页中，而是被推到缓存中。

![](../../.gitbook/assets/image%20%28343%29.png)

HTTP/2推送缓存被绑定到连接，而不是页面。当资源从连接的推送缓存中被“认领”并拿出后，就不能再从推送缓存中使用它了。推送缓存还有一点和HTTP缓存不同，那就是不缓存的资源（在HTTP cache-control首部中设置了no-cache和no-store）也可以被推送，并可以从推送缓存中读取它们。

客户端可以通过发送RST\_STREAM帧来拒绝推送资源。

#### 5.4 如何实现条件推送

* 服务器可以记录它在一个客户端的连接上推送过哪些资源。
* 客户端发送一个if-modified-since或者etag首部。
* 在客户端记录哪些资源已经被推送。cookie是做这个的理想载体。
* 缓存摘要是一个提议，浏览器用它来告诉服务器缓存里有什么内容。

#### 5.5 推送什么

推送需要的最少资源，来“填充空闲的网络时间，不要做多余的操作。

#### 5.6 HTTP/2 推送的常见问题

很多原因可能导致没有 HTTP/2 推送。

#### 5.7 HTTP/2 推送对性能的影响

高效使用HTTP/2推送的关键是利用连接未被使用时的空闲带宽。

#### 5.8 对比推送和预加载

预加载没有HTTP/2推送那么快，但是它是一个浏览器发起的请求，有一些优势：

* 浏览器知道缓存里有什么，然后它就知道是否要发出对应的请求。
* 没有那么多复杂性。
* 可以从其它域名加载资源。

#### 5.9 HTTP/2 推送的其它应用场景

### Chapter 6. HTTP/2 优化

#### 6.1 HTTP/2 对 Web 开发者的影响

HTTP/2在设计上是向后兼容的。

#### 6.2 一些 HTTP/1.1 中的优化方法是否成了反模式

压缩大文件比压缩小文件效果好。总的来说，HTTP/2可能不需要像HTTP/1.1那样有那么多的资源合并，但是在拆分文件之前要考虑一下带来的压缩率下降问题。

在HTTP/2的世界里，域名分片的意义没有那么大，并且设置和管理这些额外的基础设施也是一种负担。

HTTP/2推送要消除对内联资源的需求。

#### 6.3 在 HTTP/2 下依然有效的性能优化技术

不管HTTP/2提供了哪些方法来优化请求和响应，少发送数据总是好的。比如使用合适的文件格式和大小，压缩文本数据。

使用缓存防止重复发送数据。

Service Worker可以大幅减少网络加载。

#### 6.4 同时对 HTTP/1.1 和 HTTP/2 做优化

连接合并。HTTP/2规范允许多个域名使用同一个HTTP/2连接，这些域名被解析到同一个IP地址。

## Part 3. HTTP/2 进阶

### Chapter 7. 高级 HTTP/2 概念



### Chapter 8. HPACK 首部压缩

## Part 4. HTTP 的未来

### Chapter 9. TCP、QUIC 和 HTTP/3



### Chapter 10. HTTP 将何去何从



