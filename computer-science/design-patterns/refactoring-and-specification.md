# Refactoring & Specification

## 重构

**定义**：重构是一种对软件内部结构的改善，目的是在**不改变软件的可见行为**的情况下，使其更易理解，修改成本更低。

**为什么要重构？**

* 时刻保证代码质量。随着代码不停的堆砌，更多的人参与项目，代码会越来越乱，最后重构成本比重新开发还高。
* 优秀的代码都不能一开始就完全设计好，都是迭代出来的，随着系统的演进，重构是不可避免的。
* 避免过度设计。在迭代过程中，真正遇到问题的时候再对代码重构，避免前期投入太多精力。
* 帮助工程师技术成长。

**重构什么？**

* **大规模高层次重构**：对顶层代码设计重构，包括系统、模块、代码结构、类与类之间的关系，手段有分层、模块化、解耦、抽象可复用组件等。主要利用**设计思想、原则、模式**。影响面较大、难度较大、耗时较长、引入 BUG 风险较大。
* **小规模低层次重构**：对代码细节的重构，包括类、函数、变量等，如规范命名、规范注释、消除超大类等。主要利用**编码规范**。

**何时重构**：持续重构。平时无事时可以做一下小规模重构；在做功能开发时，遇到不规范的代码，也顺手改了。

### 解耦

过于复杂的代码可读性、可维护性都不友好。解耦是保证代码松耦合、高内聚、控制代码复杂度的有效手段。

根据模块、类与类之间的关系图的复杂性来判断是否需要解耦。

封装、抽象、中间层、模块化以及一些设计原则与思想（单一职责、基于接口而非实现、依赖注入、多用组合少用继承、迪米特等）是常用的解耦方法。

## 单元测试

单元测试（Unit Testing）是保证重构不出错的有效手段。单元测试是研发工程师自己编写，用于测试代码的正确性。相对于集成测试（Integration Testing）粒度更小。

**写单元测试的好处：**

* 能帮你发现代码中的 bug。
* 能帮你发现代码设计上的问题。代码的可测试性是一个重要的质量标准，若代码很难被测试，那么意味着代码设计不合理。
* 对集成测试的有力补充。集成测试很难覆盖全面。
* 写单元测试的过程本来就是代码重构的过程。
* 阅读单元测试能帮你快速熟悉代码。

尽管单元测试的代码量可能是被测代码的 1~2 倍，但并不耗时，因为代码逻辑简单、重复很多。单元测试不会在线上运行，所以代码质量可以降低。不能用覆盖率作为单元测试质量的唯一标准。写单元测试不需要了解代码实现逻辑。

代码的可测试性就是编写单元测试的难易程度。依赖注入是提高可测试性的有效手段。



