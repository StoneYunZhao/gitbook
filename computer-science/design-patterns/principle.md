# Principle

设计不是强行遵守的，是一个平衡的选择。

## 基于接口而非实现编程

这条原则的英文是“Program to an interface, not an implementation”，出自 1994 年的 GoF，当时很多编程语言还没诞生，比如 Java，所以这里的接口不要理解为编程语言中的接口。这条原则的接口可以理解为编程语言中的[接口或抽象类](../../java/grammar/basic.md#ji-cheng)。

这条原则将接口和实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，降低耦合性、提高扩展性。

这个原则更加贴切的表述应该是“**基于抽象而非实现编程**”，这样表述更加体现这条原则的初衷。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。

怎么做到这条原则呢？

* 函数命名不能暴露任何实现细节。比如 uploadToAliyun\(\) -&gt; upload\(\)。
* 封装具体实现。
* 为实现类定义接口。

总之，要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义**只表明做什么，而不是怎么做**。要多思考接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。

{% hint style="info" %}
**那是不是需要给每个实现类都定义对应的接口呢？**  
凡事就讲一个“度”，如果在业务场景下，某个功能只有一种实现，未来不可能被替换，那么就没必要设计接口。
{% endhint %}

## 多用组合少用继承

[继承](../../java/grammar/basic.md#ji-cheng)是面向对象的四大特性之一，表示类之间 is-a 的关系，可以解决代码复用性的问题。

### 继承的问题

**继承层次过深、过复杂会影响代码的可读性和可维护性**。下面有个例子说明这个问题：

设计一个关于鸟的类，有个抽象类 AbstractBird，麻雀、乌鸦、格子都继承这个类。

大部分鸟会飞，那我们应该在 AbstractBird 类中增加 fly 方法吗？有两种选择：

* 增加：有特例，比如鸵鸟，如果鸵鸟继承 AbstractBird，那么不符合认知；就算鸵鸟重写 fly 方法，抛出异常，这种方式虽然可以解决问题，但是不好用，因为一是违背了最小知识原则或迪米特原则，二是每种不能飞的鸟都需要重写。
* 不增加：可以把 AbstractBird 派生出两个类 AbstractFlyableBird 和 AbstractUnFlyableBird，但是鸟不但有会飞属性，还有会叫属性，如果也这么做，那么就有三层抽象，四个抽象类。依次类推，是否会下蛋属性，那么类的个数就爆炸了。

![](../../.gitbook/assets/image%20%28104%29.png)

### 组合的优势

我们可以利用组合（Composition）、接口、委托解决上述问题。我们可以定义 Flyable、Tweetable、EggLayable 接口，然后为每个接口提供实现类 FlyAbility、TweetAbility、EggLayAbility，最后具体的鸟类就实现相应的接口，并在类里面包含相应的接口实现类。如下示例代码：

```java
public interface Flyable {
  void fly()；
}
public class FlyAbility implements Flyable {
  @Override
  public void fly() { //... }
}

public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  private Tweetable tweetable = new TweetAbility(); //组合
  private EggLayable eggLayable = new EggLayAbility(); //组合
  //... 省略其他属性和方法...
  @Override
  public void tweet() {
    tweetable.tweet(); // 委托
  }
  @Override
  public void layEgg() {
    eggLayable.layEgg(); // 委托
  }
}
```

### 组合和继承应该怎么选择

组合并不是完美的，继承并不是一无是处的。由上面可以看出，继承改写为组合需要做细粒度拆分，定义更多的类和接口。

如果类之间继承结构稳定，继承层次比较浅，继承关系不复杂，那么就可以使用继承。反之，系统越不稳定，继承很深，继承关系复杂，那么就尽量使用组合。

另外一些设计模式，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。

有些场景必须使用继承，比如有些函数的参数类型我们不能改变，但是想改变参数类的行为，那么就可以继承该参数类，重写相关方法。

## 单一职责原则

Single Responsibility Principle。

**定义**：A class or module should have a single responsibility。不要存在多于一个导致类变更的原因。

核心思想：一个类、接口、方法只负责一项职责。

不同的场景对同一个类的职责是否单一的判定，可能结果是不一样的。在某种场景下一个类的设计可能已经满足单一职责原则了，但在另外的场景可能就不满足了，需要继续拆分成粒度更细的类。所以，**我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。**

有下面这些方法可以判断是否需要拆分类了：

* 类中的代码行数、函数、属性过多，影响可读性和可维护性；
* 类依赖的其它类过多；
* 私有方法过多；
* 难给类取一个名字；
* 类中大量的方法都是集中操作类中的某几个属性；

**类的职责是否越单一越好呢？**

不是的。如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。如 Serializer 有序列化和返序列化两个方法，如果把这个类拆分成 Serializer 和 Deserializer 两个类，那么当序列化协议换了之后，就需要同时修改两个类，如果只修改了一个，就会导致序列化后不能反序列化。

## 开闭原则

定义：一个软件实体，如类、模块、函数，应该对扩展开放，对修改关闭。

核心思想：用抽象构件框架，用实现扩展细节。

## 依赖倒置原则

定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象。

核心思想：面向接口编程，而不应该面向实现编程。

## 接口隔离原则

定义：用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。

核心思想：一个类对一个类的依赖应该建立在最小的接口上。尽量细化接口，接口中的方法尽可能少。**注意适度**。

## 迪米特原则

定义：一个对象应该对其它对象保持最少的了解。又叫最少知道原则。

核心思想：尽量降低类于类之间的耦合。尽量只使用成员变量、方法的输入输出参数的类型，方法体内的新类型尽量不用。

