# Recursion

可以用递归解决的问题满足三个条件：

1. 一个问题可以分解为几个子问题
2. 这个问题与分解后的子问题，除了数据规模不一样，求解思路完全一样
3. 存在递归终止条件

写递归代码的关键是写出递归公式，找到终止条件。

人思维递归不应该试图想清楚整个递和归的过程。应该的做法：若问题A可分解为子问题B、C、D，假设B、C、D已经解决，在此基础上思考如何解决A，仅需思考A与B、C、D两层的关系即可，不需要一层一层往下思考。

递归代码要警惕堆栈溢出，可限制递归最大深度来解决。

递归要警惕重复计算，可以缓存已经计算的结果。

递归会造成过多的函数调用，可以改成非递归来解决。

## 递归改成非递归

案例：假如n个台阶，每次可以跨1或2个台阶，清楚n个台阶有多少种走法

递归公式：`f(n)=f(n-1)+f(n-2)`

终止条件：`f(1)=1, f(2)=2`

递归代码：

```text
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```

非递归代码：

```text
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  int ret = 0;
  int pre = 2;
  int prepre = 1;
  for (int i = 3; i <= n; ++i) {
    ret = pre + prepre;
    prepre = pre;
    pre = ret;
  }
  return ret;
}
```

