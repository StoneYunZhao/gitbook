# Tree

## 概念

**线性表结构**：栈、队列  
**非线性表结构**：树

树（Tree）每个元素叫做**节点**，连线节点之间叫做**父子关系**。父节点指向子节点。拥有相同父节点的叫做**兄弟节点**。没有父节点的叫做**根节点**，没有子节点的叫做**叶子节点**或者**叶节点**。

**节点的高度**（Height）：节点到叶子节点的最长路径（边数）。  
**节点的深度**（depth）：根节点到这个节点所经历的边的个数。  
**节点的层数**（Level）：节点的深度+1。  
**树的高度**：根节点的高度。

**二叉树**：每个节点最多有两个子节点，分别为左子节点和右子节点。  
**满二叉树**：叶子节点都在最底层，除了叶子节点，每个节点都有左右两个子节点。  
**完全二叉树**：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，除了最后一层，其它层的节点个数都达到最大。完全二叉树用数组存储最节省内存。

**链式存储法**：每个节点有三个字段，数据和两个指针。  
**顺序存储法**：数组存储，根节点存在下标`1`的位置，如果节点X存在下标为`i`的位置，则左子节点存在`2*i`的位置，右子节点存在`2*i+1`的位置。完全二叉树仅仅浪费下标为0的位置，如果是非完全二叉树，则会浪费很多空间。

二叉树的遍历，时间复杂度`O(n)`：

* 前序遍历，节点 -&gt; 左子树 -&gt; 右子树
* 中序遍历，左子树 -&gt; 节点 -&gt; 右子树
* 后序遍历，右子树 -&gt; 左子树 -&gt; 节点

## 二叉查找树

**二叉查找树**（binary search tree）：任意节点，左子树的每个节点都小于这个节点，右子树的每个节点都大于这个节点。

* **查找：**先去根节点，若等于则返回，若比根节点小，则在左子树递归查找，若比根节点大则在右子树递归查找。
* **插入：**插入的数据都在叶子节点，从根节点开始，若插入的数据比较大，且右子树为空，则插入到右子节点，若不为空，则递归遍历右子树，找到插入位置。插入数据比较小，类似往左子树插。
* **删除：**若删除的节点没有子节点，则将删除节点的父节点指向null；若删除的节点只有一个子节点，则将删除节点的父节点指向删除节点的子节点；若删除的节点有两个子节点，找到删除节点右子树的最小节点，与删除节点替换，再应用上两条规则删除原来最小节点的位置。也可以直接标记为已删除，但是不真正删除，只是浪费内存。
* 查找最大节点。
* 查找最小节点。
* 查找前驱结点。
* 查找后继结点。
* 输出有序的数据序列，中序遍历即可，时间复杂度O\(n\)。

实际中，在二叉查找树中存储的事对象，利用对象的某个字段作为键值来构建二叉查找树，对象的其它字段叫做**卫星数据**。

**支持重复数据**的二叉查找树：

* 通过链表或者支持动态扩容的数据等数据结构作为节点，把值相同的数据都存储在同一节点上。
* 每个节点仍存储一个数据，插入数据时，若相同，则插入这个节点的右子树，即当做大于这个节点来处理；查找时，遇到值相同时，并不停止，继续在右子树查找，直到遇到叶子节点，把所有等于这个值得节点都查找出来；删除时，也是找到每个要删除的节点，依次删除。

二叉查找树的**时间复杂度**：最坏`O(n)`，最好`O(height)=O(logn)`，平均`O(logn)`。

**散列表与二叉查找树**：

* 散列表数据无序，若要输出有序数据，比较困难；二叉查找树中序遍历即可。
* 散列表扩容时耗时很多，性能不稳定；平衡的二叉查找树性能稳定。
* 尽管散列表查找为O\(1\)，但因为有散列冲突的情况，不一定比O\(logn\)好。
* 散列表的实现较复杂，要考虑散列函数的设计、冲突解决、扩容、缩容等。
* 散列表表会浪费一定的空间。

## 平衡二叉查找树

为什么需要**平衡二叉查找树**？

二叉查找树在理想情况下，插入、删除、查找操作的时间复杂度都是`O(logn)`，但是二叉查找树在频繁的动态跟新过程中，会出现退化情况，最差情况时，退化为链表。为了解决这个复杂度退化问题，所以需要平衡二叉查找树。

**平衡二叉树**：二叉树中任意一个节点的左右子树的高度相差不能大于1，完全二叉树、满二叉树都是平衡二叉树。

**平衡二叉查找树**：满足平衡二叉树的二叉查找树。AVL树、Treap、Splay Tree是严格的平衡二叉查找树。红黑树是不严格的。

## **红黑树**

* 根节点是黑色；
* 每个叶子节点都是黑色的NULL，不存储数据；
* 任何相邻节点不能同时为红色；
* 每个节点，从该节点到达其可达的叶子节点的所有路径，都包含相同数目的黑色节点。

## B 树

二叉树的搜索效率最高，但是高度较高，并且索引不止在内存中，还要写到磁盘上，每次读取节点都是一次磁盘操作，因此很多数据库不使用二叉树。为了减少磁盘的读取次数，所以应该使用 N 叉树，以 InnoDB 为例，N 大约为 1200。

B 树英文叫做 Balance Tree，也叫平衡多路搜索树，它的高度远小于平衡二叉树的高度。在文件系统和数据库系统中常采用 B 树实现索引结构。

![](../../.gitbook/assets/image.png)

一个 M\(M &gt; 2\) 阶的 B 树每个节点最多可以包含 M 个子节点，有如下特性：

* 根节点的儿子数为 \[2, M\]。
* 中间节点有 k - 1 个关键字和 k 个孩子，k 的范围 \[ceil\(M / 2\), M\]。
* 叶子节点有 k - 1 个关键字，k 的范围 \[ceil\(M / 2\), M\]。
* 中间节点的 k - 1 关键字按照顺序存放，k 个孩子指向关键字分割的 k 个范围。
* 所有叶子节点位于同一层。

## B+ 树

B+\(B more\) 树是基于 B 树做的改进，主流的 DBMS 都支持 B+ 树，如 [MySQL](../../database/mysql/indexing.md#2-mysql-suo-yin)。B+ 树的改进点如下：

* 关键字树 = 孩子树。
* 非叶子节点的关键字也会存于子节点中，并且在子节点关键字中最大（或最小）。
* 非叶子节点仅保存关键字，不保存数据，数据存放在叶子节点中。
* 叶子节点有所有关键字，并且叶子节点之间构成一个有序链表，叶子节点内部也有序。

![](../../.gitbook/assets/image%20%28214%29.png)

有了上述改进点，B+ 树有如下好处：

* B+ 树查询效率更加稳定，因为每次都必须访问到叶子节点才能找到数据；而 B 树非叶子节点也存储数据，所以可能很快就找到。
* B+ 树非叶子节点不存储数据，同样大小的磁盘页可以存储更多的关键字，所以更加矮胖，磁盘 IO 次数更少。
* B+ 树的范围查询效率要高很多。

假设有如下表和数据，则 InnoDB 的索引结构为下图：

```sql
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;

(100,1) (200,2) (300,3) (500,5) (600,6)
```

![](../../.gitbook/assets/image%20%28144%29.png)

* **主键索引**：又叫聚簇索引（clustered index），叶子节点存整行数据。
* **非主键索引**：又叫耳机索引（secondary index），叶子节点存主键的值。

若使用`select * from T where k=5`，则先搜索 k 索引树，得到 ID 再去主键索引树搜索，这称为**回表**。

#### 页分裂

当插入数据时，比如插入 700，则只需在后面追加一条记录。若插入 400，需要逻辑上移动后面的数据。若插入的页已经满了，B+ 树会申请一个新的页，然后挪动部分数据过去。

#### 页合并

若相邻两个页由于删除数据，空间利用率很低，则会把数据页合并。

