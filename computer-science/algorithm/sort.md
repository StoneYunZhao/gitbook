# Sort

## Preface

| 算法 | 时间复杂度 | 是否基于比较 |
| :---: | :---: | :---: |
| 冒泡、插入、选择 | O\(n^2\) | 是 |
| 快速、归并 | O\(nlogn\) | 是 |
| 桶、计数、基数 | O\(n\) | 否 |

| 算法 | 是否原地 | 是否稳定 | 最好 | 最坏 | 平均 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 冒泡 | 是 | 是 | O\(n\) | O\(n^2\) | O\(n^2\) |
| 插入 | 是 | 是 | O\(n\) | O\(n^2\) | O\(n^2\) |
| 选择 | 是 | 否 | O\(n^2\) | O\(n^2\) | O\(n^2\) |
| 归并 | 否:O\(n\) | 是 | O\(nlogn\) | O\(nlogn\) | O\(nlogn\) |
| 快速 | 是 | 否 | O\(nlogn\) | O\(n^2\) | O\(nlogn\) |
| 计数 | 否 | 是 | O\(n+k\)，k数据范围 |  |  |
| 桶 | 否 | 是 | O\(n\) |  |  |
| 基数 | 否 | 是 | O\(dn\)，d是位数 |  |  |

**评价排序算法的维度**：

1. 时间复杂度：最好、最坏、平均，以及对应的原始数据类型。
2. 时间复杂度的系数、常数、低阶，时间复杂度反应的是随数据规模 n 增大的增长趋势，一般是在 n 很大的情况下得出。但是在实际中，n 可能不是很大，所以在同一个阶时间复杂度下，需要考虑系数、常数、低阶。
3. 比较次数与交换（移动）次数的分析。
4. 内存消耗。原地排序（sorted in place）指空间复杂度为 O\(1\) 的排序算法。
5. 稳定性，如果待排序的序列中存在值相等的元素，经过排序之后，相等的元素之间原有的先后顺序不变。实际中，我们是根据对象的某个 field 来排序，对象还有其它 field，所以需要分析稳定性。例子：订单有时间和金额，希望 order by amount, time，那么先对时间排序，然后用稳定的排序算法对金额排序，得到的结果就是金额从小到大，相同金额从早到晚。

## Bubble Sort

n 次冒泡，每次让一个元素移动到它应该在的位置。仅会操作相邻的两个元素，比较，若不满足大小关系，则交换。

优化，当某次冒泡没有数据交换时，则完成排序。

平均时间复杂度分析方法：

有序度是数组中具有有序关系的元素对的个数，有序元素对定义：`a[i]<=a[j],i<j`。如`2,4,3,1,5,6`有序度为`4+2+2+2+1=11`。完全有序的数组的有序度叫满有序度\(`n*(n-1)/2`\)。逆序度=满有序度-有序度。

冒泡有两个比较和交换两个操作，每次交换，有序度加1，所以交换次数=逆序度。平均交换次数`n*(n-1)/4`，比较次数&gt;交换次数，时间复杂度上限O\(n^2\)，所以平均时间复杂度O\(n^2\)。

注意此种平均时间复杂度分析并不严格。

## Insertion Sort

将数组分为两个区域，已排序和未排序，初始已排序为第一个元素。每次取未排序的第一个元素，在已排序中找到合适位置插入。

包含比较和移动两种操作。移动次数等于逆序度。

## Selection Sort

将数组分为两个区域，已排序和未排序，初始已排序为空，每次找到未排序的最小元素，放入已排序的末尾，即与未排序的第一个元素交换。

为什么插入比冒泡更好：

冒泡和插入的交换或移动次数是固定的，等于逆序度。但是冒泡一次交换需要三个操作，差插入一次移动仅需一个操作。

插入的优化，希尔排序，开始用大的步长，最后一次就是普通的插入，但是基本已经排好序。用大的步长是每次可以移动较大的位置。

冒泡与选择仅用作理论，实际中基本不用，而插入有时会用到。

若是链表实现，冒泡的交换操作更加复杂，插入不需要移动，直接插入，选择的交换同样比较复杂。

## Merge Sort

先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并。

采用分治的思想。

递推公式：`merge_sort(p,r)=merge(merge_sort(p,q),merge_sort(q+1,r))`

终止条件：`p>=r`

其中q等于p和r的中间位置。

时间复杂度分析：

```text
T(1)=C
T(n)=2*T(n/2)+K
```

其中K为将两个子问题合并所需时间，`K=O(n)`。所以归并时间复杂度为O\(nlogn\)，与原始数据有序程度无关。

## Quick Sort

快排也是分治思想，将A\[p:r\]排序，选择p到r之间任意一个数据作为pivot（分区点），将小于pivot的放到左边，大于pivot的放到右边，pivot放到中间。

递推公式：`quick_sort(p,r)=quick_sort(p,q-1)+quick_sort(q+1,r)`

终止条件：`p>=r`

快排的分区函数类似选择排序：将数组分为两个区域，初始已处理为空，每次从未处理选一个与pivot比较，若小于pivot，则放入已处理末尾，即与未处理的第一个元素交换。

快速排序涉及交换，所以不稳定。

时间复杂度分析：

```text
T(1)=C
T(n)=2*T(n/2)+n
```

时间复杂度也是O\(nlogn\)，但是前提是每次选择pivot都能将取件一分为二，实际上很难实现。最坏情况，即数组已经有序，选择最后一个元素作为pivot，则O\(n^2\)。.

归并与快速的区别：归并是由下到上，先处理子问题，再合并；快速是由上到下，先分区，再处理子问题。

O\(n\)时间复杂度求无序数组中第K大元素：将数组A\[0:n-1\]最后一个元素A\[n-1\]，作为pivot，原地分区，分成了A\[0:p-1\],A\[p\],A\[p+1:n-1\]，若p+1=K，则A\[p\]就是要求解的，否则按上述思路继续查找。时间复杂度为n+n/2+n/4+n/8+...+1=2n-1，为O\(n\)。

线性排序时间复杂度是线性O\(n\)的：桶排序、计数排序、基数排序。能做线性，原因都是非基于比较，不涉及元素之间比较操作。

## Bucket Sort

将排序的数据分到几个有序的桶中，桶内单独排序，再按照桶的顺序依次取出。

时间复杂度O\(n\)，n个数据，m个桶，k=n/m，`O(m*k*logk=n*log(n/m))`，当m接近n时，log\(n/m很小\)。

从复杂度分析来看，对数据要求严格：数据很容易划分成m个桶，桶与桶有天然顺序，能够比较均匀分布在各个桶中。

桶排序比较适合用在外部排序，数据量大，无法加载到内存中。

## Counting Sort

计数排序是特殊的桶排序。需要排序的n个数据，仅有k个可能值，则放入k个桶中，桶内不需要排序。

准备一个大小为k的数组C，扫描一遍数据，C中存放各个可能值的个数。依次累加C，所以C\[i\]中存放小于等于i的个数。准备大小为n的数组R，从后往前扫描数据，扫描到i，则`R[C[i]]=i, C[i]=C[i]-1`。

高考成绩排序，分数最高900，则放入901个桶中。

数据要求：数据值范围不大，只能给非负整数排序，若是其它类型，在不改变相对大小的情况下，转化为非负整数。

## Radix Sort

对手机号排序，从低位开始，每一位分别排序。要求稳定的排序。

若数据不是等长，可以补齐。

数据要求：可以分割出位，位有递进关系，高位比较大，则低位就不用比较了，每一位的数据范围不大，对每位就可以用线性排序了。

## 工程应用

排序函数

* 通用，所以不能选择对数据要求比较严格的线性排序
* 小规模数据可选择O\(n^2\)，大规模一般选择O\(nlogn\)
* O\(nlogn\)比较多，java采用堆排序，C采用快速排序
* 归并用的少，原因是非原地。
* 解决快排在最坏情况O\(n^2\)的方式：a、首、尾、中三个数取中间值；b、随机；
* 快排递归，防止栈溢出，可以限制深度，也可以手动实现栈。

Glibc 的 qsort：

* 优先使用归并，在数据量小时。
* 数据量大，变成快排。
* 快排采用三数取中法。
* 自己在堆上实现栈。
* 当排序取件小于等于4时，退化为插入。

O\(n^2\) 算法不一定比 O\(nlogn\) 执行时间长：

* 时间复杂度反映的是增长趋势
* 但是会省略低阶、常数、系数，所以数据量小时，O\(n^2\) 可能会更快。

