# Search

二分查找针对有序的数据集合，每次与区间中间元素对比，将待查找区间缩为一半，直到找到活区间被缩小为0。

时间复杂度O\(logn\)，O\(logn\)极其高效，有时甚至比常量级更高效。

最简单情况是有序数组中不存在重复元素。

有递归和非递归实现。

代码要点：

* 循环退出条件：`low<=high`
* mid取值：`mid=(low+high)/2`可能造成溢出，改为`low+((high-low)>>1)`
* `low=mid+1,high=mid-1`，而不是`low=mid,high=mid`，因为会造成死循环。

局限性：

* 依赖顺序表结构，因为需要下标随机访问。
* 需要有序数据。若不有序，需要插入、删除不频繁，一次排序多次查找的情况。
* 数据量小时没必要用二分，直接顺序查找。例外，数据比较耗时，如长度为300的字符串，那么此时就算数据量小也要二分。
* 数据量大不合适，因为需要连续内存。

大部分情况，用二分查找解决的问题，都可以用散列表和二叉树解决，但是后者需要额外的内存空间。

当有序数组中存在重复数据时，稍微复杂。二分查找变体：

1. 查找第一个值等于给定值的元素。
2. 查找最后一个值等于给定值得元素。
3. 查找第一个大于等于给定值的元素。
4. 查找最后一个小于等于给定值的元素。

