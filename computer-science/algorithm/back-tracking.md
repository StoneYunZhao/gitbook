# Back Tracking

回溯的处理思想，类似于枚举。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有的解，避免重复和遗漏，把问题求解的过程分为多个阶段。每个阶段，会有多个选择，随意选择一个，若发现这个选择不满足条件，则回到上一步，做另外一个选择。

比如深度优先遍历即使用的回溯思想。

回溯算法一般适用用递归来实现。剪枝操作是提高回溯效率的一种技巧。

## 案例

### 八皇后

问题：有一个 8\*8 的棋盘，往里面放 8 颗棋子，每个棋子所在和行、列、对角线都不能有另一个棋子。

思路：将问题分为 8 个步骤，依次将棋子放在 1 到 8 行。放置过程中，检查是否满足要求，若满足，则进行下一步，即到下一行继续放棋子；若不满足，则换一种放法。

### 0-1 背包

问题：一个背包总承重 W kg，有 n 个重量不等的物体，选择几件物品装到背包中，使背包中的总重量最大。

注意：此问题与[贪心算法中的背包问题](greedy-algorithm.md#bei-bao-wen-ti)区别在于这里的物体不能分割，只能选择装或不装，所以叫做 0-1 问题。此类问题用[动态规划](dynamic-programming.md)效率更高。

思路：用回溯思想的话，若有 n 个物体，把问题分为 n 个阶段，每个阶段对应是否选择物品。可以用一点剪枝技巧，当已经选择的物品超过 W 后，就停止后面的阶段。

```java
public int maxW = Integer.MIN_VALUE; //存储背包中物品总重量的最大值
// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；
// w背包重量；items表示每个物品的重量；n表示物品个数
// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：
// f(0, 0, a, 10, 100)
public void f(int i, int cw, int[] items, int n, int w) {
  if (cw == w || i == n) { // cw==w表示装满了;i==n表示已经考察完所有的物品
    if (cw > maxW) maxW = cw;
    return;
  }
  f(i+1, cw, items, n, w); // 表示不选择此阶段的物品
  if (cw + items[i] <= w) {// 已经超过可以背包承受的重量的时候，就不要再装了
    f(i+1,cw + items[i], items, n, w); // 表示选择此阶段的物品
  }
}
```

### 正则

