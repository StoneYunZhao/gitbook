# Transaction

## 概念

事务就是指一组数据库操作，要么全部成功，要么全部失败。

### ACID

* Atomicity：原子性。
* Consistency：一致性。
* Isolation：隔离性。
* Durability：持久性。

### 事务带来的问题

当数据库有多个事务同时执行的时候，可能会出现以下问题：

* **脏读（dirty read）**：一个事务读取了另一个事务未提交的数据。
* **不可重复读（non-repeatalble read）**：一个事务由于另一个事务的提交导致前后两次读到的**数据不一致**。
* **幻读（phantom read）**：一个事务由于另一个事务的提交导致前后两次读到的**数据行数不一致**。

### 隔离级别

隔离级别越高，效率越低，所以我们需要找一个平衡点。

* **read uncommitted**：一个事务还没提交，它的变更就能被别的事务看到。存在脏读、不可重复读、虚读的问题。
* **read committed**：一个事务被提交之后，它的变更才能被别的事务看到。存在不可重复读、虚读的问题。Oracle 的默认级别。
* **repeatable read**：一个事务在执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。存在虚读问题。MySQL 的默认级别。
* **serializable**：后访问的数据必须等前一个事务执行完成才能继续执行，是最高事务级别。

假设有如下表和数据，并且有两个事务 A、B：

```sql
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

| 事务 A | 事务 B |
| :---: | :---: |
| 启动事务 A | 启动事务 B |
| 查询得到 1 |   |
|   | 查询得到 1 |
|   | 将 1 改为 2 |
| 查询得到 V1 |   |
|   | 提交事务 B |
| 查询得到 V2 |   |
| 提交事务 A |   |
| 查询得到 V3 |   |

那么在不同隔离级别下，各 V 的值为：

| 隔离级别 | V1 | V2 | V3 |
| :---: | :---: | :---: | :---: |
| 读未提交 |  2 | 2 | 2 |
| 读提交 | 1 | 2 | 2 |
| 可重复读 | 1 | 1 | 2 |
| 串行化 | 1 | 1 | 2 |

{% hint style="info" %}
可重复读和串行化所看到的结果虽然一样，但是执行方式不一样。串行化的情况下，当事务 B 在修改数据时，会被阻塞，直到事务 A 提交，事务 B 才能继续执行。
{% endhint %}

## MySQL 事务

MyISAM 不支持事务，InnoDB 支持事务。

默认级别是可重复读，可以配置启动参数`transaction-isolation`。

```sql
# 查询超过 60s 的事务
select *
from information_schema.innodb_trx
where TIME_TO_SEC(timediff(now(), trx_started)) > 60;
```

### 启动方式

#### 显式启动

* begin 或 start transaction
* commit 或 rollback

#### autocommit 参数

* set  autocommit=0：关闭自动提交，比如执行一个 select 语句，事务就启动了，并且不会自动提交，事务持续直到执行 commit 或 rollback 或断开连接。
* set autocommit=1：若显式启动事务，则需要使用 commit 或 rollback；若没有显式启动事务，则每个 sql 语句都会自动启动事务并自动提交。

### 实现原理

* 读未提交直接返回记录上的最新值。
* 读提交在每个 SQL 语句开始的时候创建视图。
* 可重复读在事务启动的时候创建视图。
* 串行化通过加锁来避免并行访问。

**以可重复读为例**，分析事务的原理。

MySQL 的每个更新操作都会记录一条回滚操作。如下图，一个值按照顺序由 1 被改成了 2、3、4。不同时刻启动的事务有不同的 read-view，即同一条记录可以存在多个版本，即**多版本并发控制（MVCC）**。

![](../../.gitbook/assets/image%20%28109%29.png)

**回滚日志的删除**：系统会判断，当没有事务在需要用到这些回滚日志，即没有比这个回滚日志更早的 read-view 时，回滚日志会被删除。

{% hint style="info" %}
所以尽量不要用长事务，因为会存在很老的视图，回滚日志就不能删除。
{% endhint %}

